<navbar></navbar>
<h1>{% verbatim %}{{ $ctrl.name }}{% endverbatim %} - page with demos</h1>

<section>
  <h2>Standalone component demo</h2>

  <p>
    This demo shows that external, framework-agnostic components can be
    embedded inside an application.
  </p>

  <h3>Overview</h3>

  <p>There are 3 entities:</p>
  <ol>
    <li>
      <strong>the application</strong> - it takes care about the routing and
      it has its own logic
    </li>
    <li>
      <strong>the external component</strong> - it does it's thing and it does
      it well. Whether it can do input and output operations it entirely up to
      that component's implementers. It does not assume it works within an
      application or what framework that application uses. If it uses any
      libraries it either has them bundled or it expects them to be available
      in the surroundings (pretty much like every 3rd party front end code has
      ever done)
    </li>
    <li>
      <strong>the component adapter</strong> - it's a part of the application
      (if no other application using the same framework is likely to reuse it)
      or at least it's an external module (otherwise) but it has 2 features:
      <ul>
        <li>
          it knows the framework API (in this case: it's Angular 1.5+ Component)
        </li>
        <li>
          it knows the external component API (in this case:
          <code>test-standalone-component</code>)
        </li>
      </ul>
    </li>
  </ol>

  <h3>Demo</h3>

  <p>
    Input below is managed by the application. Its content will be shown
    inside standalone component. The content will be updated in real time.
  </p>

  <input type="text" ng-model="$ctrl.standaloneComponentDemoInputValue">

  <p>
    What's inside an outlined box below is the <strong>component
      adapter</strong>. The border is applied by the application but all
    the styles inside belong either to the adapter or to
    the <strong>component</strong> it wraps.
  </p>

  <test-standalone-component
    class="demo-component-adapter"
    name="$ctrl.standaloneComponentDemoInputValue"
    on-clicked="$ctrl.externalComponentClicked()"></test-standalone-component>

  <p>
    When you clicked on the component it did run its internal logic. By the
    time this demo was prepared the logic was: "apply <code>active</code>
    class" onto the main node, but this behavior is not guaranteed neither it
    is controlled from within the application. Try it!
  </p>

  <p>
    You might have noticed that when you clicked the component another action
    was performed: the content of the input field above was set to
    "{% verbatim %}{{ $ctrl.standaloneComponentDemoInputDefaultValue }}{% endverbatim %}
    ".
    This is <strong>application's</strong> behavior <em>what</em> content was
    assigned, but the fact that it happened when you clicked originates in the
    <strong>external component</strong>. <strong>adapter</strong> exposes
    component API to the application. In this case: it creates what Angular
    1.x calls "a binding" so application function can be called when something
    internal (reaction to click interaction) happened in the component.
  </p>
</section>


<section>
  <h2>Application component remote configuration demo</h2>

  <p>This demo shows that application template can be configured
    via a remote service</p>
  <p>Text below is interpolated at compile time (it means it's recompiled each
    time the template changes) but the value content comes from is fetched once
    when compiler is run.</p>
  <p>To see changes you should:</p>
  <ol>
    <li>Go to the configuration service and find a form for configuring a
      component named "about"
    </li>
    <li>Change the string representing a key named
      "someKey.onlySource.andComponent.know"
    </li>
    <li>Stop current run of the application</li>
    <li>Start again</li>
  </ol>

  <p>
    Mind that the value you will provide is not escaped in any way.
    This means you may use the full capabilities of the template engine the
    application uses (Angular 1.x templates in this case).
  </p>
  <ol>
    <li>Try using
      <code>
        {% verbatim %}
      <span ng-non-bindable>{{ $ctrl.name }}</span>
      {% endverbatim %}
      </code>
      <br>
      You should see "{% verbatim %}{{ $ctrl.name }}{% endverbatim %}"
    </li>

    <li>Try using
      <code>
        {% verbatim %}
        <span ng-non-bindable>{{ $ctrl.remoteConfigurationDemoInputValue }}</span>
        {% endverbatim %}
      </code>
      <br>
      You should see dynamically updated content
      of this input: <input type="text" ng-model="$ctrl.remoteConfigurationDemoInputValue">
    </li>
  </ol>

  <div>{{ about.someKey.onlySource.andComponent.know }}</div>
</section>

<section>
  <h2>External component remote & local configuration demo</h2>

  <p>
    Let's combine both concepts shown above and try to configure external
    component remotely.
  </p>

  <p><em>WAIT!</em> Is't it up to the <strong>external</strong> component how it's configured if it's external?</p>
  <p>
    If it should affect all the places, all the applications it's used in then
    yes. But if in Application 1 the component should have feature X enabled
    while in Application B it should have it disabled then it's application's
    job to pass that option to the component.
  </p>

  <h3>External component configuration</h3>

  <table
    {# TODO: find a way to expose remote config to runtime other than via template #}
    ng-init="localIsRTL = {{ about.testStandaloneComponentConfig.isRTL ? 'true' : 'false' }};">
    <tr>
      <th>Feature / Source</th>
      <th>Remote</th>
      <th>Local</th>
    </tr>
    <tr>
      <th><code>isRTL</code></th>
      <td>
        <p>
          To change it you have to perform steps described in demo above
        </p>
        <p>
          <code>isRTL</code> set to
          <code>{{ about.testStandaloneComponentConfig.isRTL ? 'true' : 'false' }}</code>
        </p>
      </td>
      <td>
        <p>
          Be default it's set to the same value
        </p>
        <p>
          <code>isRTL</code> <input
            type="checkbox"
            ng-model="localIsRTL">
        </p>
        <p>
          <code>isRTL</code> set to
          <code>{% verbatim %}{{ localIsRTL ? 'true' : 'false' }}{% endverbatim %}</code>
        </p>
      </td>
    </tr>
    <tr>
      <th><code>delayedOnClicked</code></th>
      <td><em>no remote value (for brevity)</em></td>
      <td>
        <p>
          <code>delayedOnClicked</code> <input
            type="checkbox"
            ng-model="$ctrl.standaloneComponentAdapterDelayedOnClicked">
        </p>
        <p>
          External component does not have <code>delayedOnClicked</code>.
          <br>
          The adapter has it.
          <br>
          We could configure the adapter remotely as well.
        </p>
        <p>
          Let's say <code>delayedOnClicked</code> means
          <br>"should the <code>onClicked</code> binding work immediately
          <br>(if <code>false</code>) or with a delay (if <code>true</code>).
        </p>
        <p>
          Mind that it does not affect the internal behavior
          <br>(applying <code>active</code> class) but rather
          application behavior
          <br>(resetting the input to "{% verbatim %}
          {{ $ctrl.standaloneComponentDemoInputDefaultValue }}{% endverbatim %}")
        </p>
        <p>
          <code>delayedOnClicked</code> set to
          <code>{% verbatim %}{{ $ctrl.standaloneComponentAdapterDelayedOnClicked ? 'true' : 'false' }}{% endverbatim %}</code>
        </p>
      </td>
    </tr>
  </table>

  <input type="text" ng-model="$ctrl.standaloneComponentDemoInputValue">

  <test-standalone-component
    class="demo-component-adapter"
    is-right-to-left="localIsRTL"
    delayed-on-clicked="$ctrl.standaloneComponentAdapterDelayedOnClicked"
    name="$ctrl.standaloneComponentDemoInputValue"
    on-clicked="$ctrl.externalComponentClicked()"></test-standalone-component>

</section>
